<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>CAS on 随记</title><link>/tags/cas/</link><description>Recent content in CAS on 随记</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Tue, 27 Aug 2019 23:37:29 +0800</lastBuildDate><atom:link href="/tags/cas/index.xml" rel="self" type="application/rss+xml"/><item><title>Wolfram 语言：快速编程入门</title><link>/posts/wolfram-language-fast-introduction-for-programmers/</link><pubDate>Tue, 27 Aug 2019 23:37:29 +0800</pubDate><guid>/posts/wolfram-language-fast-introduction-for-programmers/</guid><description>&lt;p&gt;&lt;a href="http://www.wolfram.com/language/fast-introduction-for-programmers/zh/"&gt;http://www.wolfram.com/language/fast-introduction-for-programmers/zh/&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Shift + Enter&lt;/code&gt; 开始计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Quit&lt;/code&gt; 退出当前 Math Kernel 会话，再次计算会自动启动新的 Math Kernel 会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;In[n]&lt;/code&gt;, &lt;code&gt;Out[n]&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt; 表示上一次输出, &lt;code&gt;%%&lt;/code&gt;表示上上次输出，依次类推；&lt;code&gt;%n&lt;/code&gt; 表示 &lt;code&gt;Out[n]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;CMD&lt;/kbd&gt;+&lt;kbd&gt;L&lt;/kbd&gt; 复制并粘贴上一次输入&lt;/li&gt;
&lt;li&gt;所有符号表达式都具有相同的基本结构：&lt;code&gt;head[arguments]&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FullForm[expr]&lt;/code&gt;: 显示底层结构&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Head[expr]&lt;/code&gt;: 给出表达式的头部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Length[expr]&lt;/code&gt;: 给出表达式中参数的个素&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;List
&lt;ol&gt;
&lt;li&gt;字面语法：&lt;code&gt;{a, b, c}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;索引：&lt;code&gt;list[[i]]&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; 从 1 开始，负数表示从末尾开始计数&lt;/li&gt;
&lt;li&gt;许多运算符都是向量化运算，比如 &lt;code&gt;{1, 2, 3} + 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列表切片：&lt;code&gt;list[[i ;; j]]&lt;/code&gt;，闭区间&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Iterator
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Table[x^2, {x, MAX}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Table[x^2, {x, MIN, MAX}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Table[x^2, {x, MIN, MAX, STEP}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Table[x * y, {x, ...}, {y, ...}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array[f, n]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Assignment
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 表示立即赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:=&lt;/code&gt; 表示延迟复制，被用到时重新计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var = .&lt;/code&gt; 清除赋值&lt;/li&gt;
&lt;li&gt;局部变量：&lt;code&gt;Module[{a = 1}, a + 8]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Pattern
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt; （读做 blank）表示任意表达式: &lt;code&gt;Replace[f[100]， f[x_] -&amp;gt; x + 5]&lt;/code&gt;，这里 &lt;code&gt;x_&lt;/code&gt; 是 &lt;code&gt;x: _&lt;/code&gt; 的简写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__&lt;/code&gt; (double blank) 表示任意表达式序列：&lt;code&gt;Cases[{f[1, 2], f[1], g[3]}, f[__]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a | b | c&lt;/code&gt; 表示或者：
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Cases[{f[1], g[2], f[2], f[5]}, f[1 | 5]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cases[{f[1], g[2], f[2], f[5]}, (f | g)[2]]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_head&lt;/code&gt; 匹配包含头部 &lt;code&gt;head&lt;/code&gt; 的表达式：&lt;code&gt;Cases[{1, 2.5, 3.5, 4}, _Real]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; 使用模式来定义规则，规则右边的表达式在定义时即计算: &lt;code&gt;f[x_] -&amp;gt; x + RandomReal[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:&amp;gt;&lt;/code&gt; 与 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的区别是在规则使用时才计算右边表达式： &lt;code&gt;f[x_] :&amp;gt; x + RandomReal[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/.&lt;/code&gt; 表示&amp;quot;替换所有”（应用重写规则)： &lt;code&gt;{f[1], g[2], f[5], g[3]} /. f[x_] -&amp;gt; x + 5&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[x_, y_] := x - y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[x_, y_] := x - y /; x &amp;gt; y&lt;/code&gt;, &lt;code&gt;/; x &amp;gt; y&lt;/code&gt; 表示当 x &amp;gt; y 时才应用这个函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[1] = 2&lt;/code&gt;, &lt;code&gt;f[2] = 3&lt;/code&gt;， 定义过的 case 会计算，没定义的 case 保留原样: &lt;code&gt;{f[1], f[2], f[3], f[4]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Clear[f]&lt;/code&gt; 清除函数定义&lt;/li&gt;
&lt;li&gt;Pure function(匿名函数，lambda 表达式)
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;expr &amp;amp;&lt;/code&gt;， 表达式中的 # 或者 #1 表示第一个参数，#2 表示第二个参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function[{x, y}, expr]&lt;/code&gt;，命名参数的匿名函数&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Apply function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map[f, {a, b, c, d}]&lt;/code&gt;, 简写 &lt;code&gt;f /@ {a, b, c, d}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map[f, expr, levelspec]&lt;/code&gt;，默认在 level 1 操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Apply[f, {a, b, c, d}]]&lt;/code&gt; 等价于 &lt;code&gt;f[a, b, c, d]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Apply[f, expr, levelspec]&lt;/code&gt;，默认在 level 0 操作，将 expr 的对应 level 的 head 替换成 f&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt; 是普通函数调用：&lt;code&gt;f @ {{a, b}, {c, d}}&lt;/code&gt; 等价于 &lt;code&gt;f[{{a, b}, {c, d}}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@@&lt;/code&gt; 等价于 &lt;code&gt;Apply&lt;/code&gt;(apply at level 0): &lt;code&gt;f @@ {{a, b}, {c, d}}&lt;/code&gt; 等价于 &lt;code&gt;f[{a, b}, {c, d}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@@@&lt;/code&gt; 等价于 &amp;ldquo;apply at level 1&amp;rdquo;: &lt;code&gt;f @@@ {{a, b}, {c, d}}&lt;/code&gt; 等价于 &lt;code&gt;{f[a, b], f[c, d]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr // f&lt;/code&gt; 等价于 &lt;code&gt;f[expr]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NestList[f, x, n]&lt;/code&gt; 相当于 &lt;code&gt;{x, f[x], f[f[x]], ...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nest[f, x, n]&lt;/code&gt; 相当于 &lt;code&gt;f[f[f[....f[x]]]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NestGraph[f, x, n]&lt;/code&gt; 嵌套的应用 f，形成一个图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FoldList[f, x, list]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数选项(Options)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Func[arguments, nameA -&amp;gt; valueA, ...]&lt;/code&gt;， 使用 &lt;code&gt;:&amp;gt;&lt;/code&gt; 替换 &lt;code&gt;-&amp;gt;&lt;/code&gt; 表示每次用到这个 option 时都重新计算（跟 rule 的定义方式一致)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Options[Func]&lt;/code&gt; 查看函数的所有选项&lt;/li&gt;
&lt;li&gt;Graphics&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ListLinePlot[{5, 6, 1, 5, 7, 8, 1, 3}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Graph[{1 -&amp;gt; 3, 1 -&amp;gt; 2, 2 -&amp;gt; 4, 4 -&amp;gt; 5, 5 -&amp;gt; 1}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Graphics[{Orange, Disk[{0, 0}], Opacity[.7], Pink, Disk[{1, 0}]}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Interactive Interaces&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Manipulate[Plot[Sin[a x], {x, 0, 10}], {a, 1, 5}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;过程式编程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Print[a]; Print[b]; Print[c]&lt;/code&gt; 分号分隔表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Module[]&lt;/code&gt; 词法作用域，变量存放在后端（Math Kernel） 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Block[]&lt;/code&gt; 动态作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DynamicModule[]&lt;/code&gt; 词法作用域，变量存放在前端（Notebook） 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sow/Reap&lt;/code&gt; vs. &lt;code&gt;Throw/Catch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;True&lt;/code&gt;, &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;If&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数字: &lt;code&gt;N[expr, precision]&lt;/code&gt; 和 &lt;code&gt;expr`precision&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 连接字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~~&lt;/code&gt; 连接正则表达式和字符串&lt;/li&gt;
&lt;li&gt;输入 Unicode 字符：&lt;code&gt;\[Alpha]&lt;/code&gt;, &lt;kbd&gt;ESC&lt;/kbd&gt;&lt;kbd&gt;A&lt;/kbd&gt;&lt;kbd&gt;ESC&lt;/kbd&gt;, &lt;code&gt;\:03b1&lt;/code&gt; 都是输入 &lt;code&gt;α&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串模版：&lt;code&gt;TemplateApply[&amp;quot;number `` date: &amp;lt;* Now *&amp;gt;&amp;quot;, {56}]&lt;/code&gt;, `` 表示占位符，&lt;code&gt;&amp;lt;* expr *&amp;gt;&lt;/code&gt; 表示插值&lt;/li&gt;
&lt;li&gt;关联 (Associations)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;|&amp;quot;a&amp;quot; -&amp;gt; x, &amp;quot;b&amp;quot; -&amp;gt; y|&amp;gt;&lt;/code&gt; 定义关联，&lt;code&gt;expr[key]&lt;/code&gt; 获取值&lt;/li&gt;
&lt;li&gt;匿名函数中可以用 &lt;code&gt;#key&lt;/code&gt; 得到关联中的值：&lt;code&gt;{#b, 1 + #b}&amp;amp;[&amp;lt;|&amp;quot;a&amp;quot;-&amp;gt;x, &amp;quot;b&amp;quot;-&amp;gt;y|&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关联和列表同时使用：&lt;code&gt;&amp;lt;|&amp;quot;a&amp;quot; -&amp;gt; x, &amp;quot;b&amp;quot; -&amp;gt; {5, 6}|&amp;gt;[[&amp;quot;b&amp;quot;, 1]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串模版：&lt;code&gt;TemplateApply[&amp;quot;first `a`; second `b`; first `a`&amp;quot;, &amp;lt;|&amp;quot;a&amp;quot; -&amp;gt; x, &amp;quot;b&amp;quot; -&amp;gt; y|&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item></channel></rss>