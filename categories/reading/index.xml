<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Reading on 随记</title><link>/categories/reading/</link><description>Recent content in Reading on 随记</description><generator>Hugo</generator><language>zh-cn</language><lastBuildDate>Sat, 29 Nov 2025 11:00:00 +0800</lastBuildDate><atom:link href="/categories/reading/index.xml" rel="self" type="application/rss+xml"/><item><title>绳结的“叛逃”：一场关于安全、拓扑与信任的无声博弈</title><link>/posts/traps-in-knots/</link><pubDate>Sat, 29 Nov 2025 11:00:00 +0800</pubDate><guid>/posts/traps-in-knots/</guid><description>&lt;blockquote&gt;
&lt;p&gt;对 &lt;a href="https://zhuanlan.zhihu.com/p/1978047331690628089"&gt;绳结简介&lt;/a&gt; 的演绎，由网友 Huand 使用 AI 生成。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id="引言看不见的几何世界"&gt;引言：看不见的几何世界&lt;/h2&gt;
&lt;p&gt;在登山者指尖、水手掌间、甚至你系鞋带的瞬间，一个充满魔力的几何世界正在悄然运转。绳结，这门古老的艺术，远不止是绳子的缠绕。它是一种立体的拓扑学，是力量与摩擦的平衡术，更是生死攸关的信任契约。然而，并非所有绳结都值得托付。有些绳结，在压力下会悄然“叛逃”——松弛、翻转甚至完全失效。今天，我们将跟随一位严谨的“绳结侦探”，揭开那些被划掉的不安全绳结背后的秘密，并探索拓扑学如何成为我们选择盟友的终极罗盘。&lt;/p&gt;</description></item><item><title>关于软件设计和系统架构的书籍</title><link>/posts/books-about-software-design-and-architecture/</link><pubDate>Thu, 02 Jan 2025 22:00:00 +0800</pubDate><guid>/posts/books-about-software-design-and-architecture/</guid><description>&lt;table&gt;
 &lt;thead&gt;
 &lt;tr&gt;
 &lt;th style="text-align: center"&gt;&lt;/th&gt;
 &lt;th&gt;书名&lt;/th&gt;
 &lt;th&gt;作者&lt;/th&gt;
 &lt;th&gt;年份&lt;/th&gt;
 &lt;/tr&gt;
 &lt;/thead&gt;
 &lt;tbody&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;1&lt;/td&gt;
 &lt;td&gt;The Mythical Man-Month&lt;/td&gt;
 &lt;td&gt;Frederick P. Brooks&lt;/td&gt;
 &lt;td&gt;1974&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;2&lt;/td&gt;
 &lt;td&gt;Algorithms + Data Structures = Programs&lt;/td&gt;
 &lt;td&gt;Niklaus Wirth&lt;/td&gt;
 &lt;td&gt;1976&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;3&lt;/td&gt;
 &lt;td&gt;Programmers at Work&lt;/td&gt;
 &lt;td&gt;Susan M. Lammers&lt;/td&gt;
 &lt;td&gt;1986&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;4&lt;/td&gt;
 &lt;td&gt;The Tao of Programming&lt;/td&gt;
 &lt;td&gt;Geoffrey James&lt;/td&gt;
 &lt;td&gt;1986&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;5&lt;/td&gt;
 &lt;td&gt;Peopleware&lt;/td&gt;
 &lt;td&gt;Tom DeMacro, Tim Lister&lt;/td&gt;
 &lt;td&gt;1987&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;6&lt;/td&gt;
 &lt;td&gt;The Zen of Programming&lt;/td&gt;
 &lt;td&gt;Geoffrey James&lt;/td&gt;
 &lt;td&gt;1988&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;7&lt;/td&gt;
 &lt;td&gt;Code Complete&lt;/td&gt;
 &lt;td&gt;Steve McConnell&lt;/td&gt;
 &lt;td&gt;1993&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;8&lt;/td&gt;
 &lt;td&gt;Design Patterns&lt;/td&gt;
 &lt;td&gt;Erich Gamma, Richard Helm, et al.&lt;/td&gt;
 &lt;td&gt;1994&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;9&lt;/td&gt;
 &lt;td&gt;The Practice of Programming&lt;/td&gt;
 &lt;td&gt;Brian W. Kernighan, Rob Pike&lt;/td&gt;
 &lt;td&gt;1999&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;10&lt;/td&gt;
 &lt;td&gt;The Pragmatic Programmer&lt;/td&gt;
 &lt;td&gt;Andrew Hunt, David Thomas&lt;/td&gt;
 &lt;td&gt;1999&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;11&lt;/td&gt;
 &lt;td&gt;Agile Software Development&lt;/td&gt;
 &lt;td&gt;Robert C. Martin&lt;/td&gt;
 &lt;td&gt;2002&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;12&lt;/td&gt;
 &lt;td&gt;Patterns of Enterprise Application Architecture&lt;/td&gt;
 &lt;td&gt;Martin Fowler&lt;/td&gt;
 &lt;td&gt;2002&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;13&lt;/td&gt;
 &lt;td&gt;The Art of UNIX Programming&lt;/td&gt;
 &lt;td&gt;Eric Steven Raymond&lt;/td&gt;
 &lt;td&gt;2003&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;14&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/toc.html"&gt;Enterprise Integration Patterns&lt;/a&gt;&lt;/td&gt;
 &lt;td&gt;Gregor Hohpe, Bobby Woolf&lt;/td&gt;
 &lt;td&gt;2003&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;15&lt;/td&gt;
 &lt;td&gt;Code Readings&lt;/td&gt;
 &lt;td&gt;Diomidis Spinellis&lt;/td&gt;
 &lt;td&gt;2003&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;16&lt;/td&gt;
 &lt;td&gt;Domain Driven Design&lt;/td&gt;
 &lt;td&gt;Eric Evans&lt;/td&gt;
 &lt;td&gt;2003&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;17&lt;/td&gt;
 &lt;td&gt;Working Effectively with Legacy Code&lt;/td&gt;
 &lt;td&gt;Michael C. Feathers&lt;/td&gt;
 &lt;td&gt;2004&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;18&lt;/td&gt;
 &lt;td&gt;Joel on Software&lt;/td&gt;
 &lt;td&gt;Joel Spolsky&lt;/td&gt;
 &lt;td&gt;2004&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;19&lt;/td&gt;
 &lt;td&gt;Code Craft&lt;/td&gt;
 &lt;td&gt;Pete Goodliffe&lt;/td&gt;
 &lt;td&gt;2006&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;20&lt;/td&gt;
 &lt;td&gt;Beautiful Code&lt;/td&gt;
 &lt;td&gt;Andy Oram, Greg Wilson&lt;/td&gt;
 &lt;td&gt;2007&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;21&lt;/td&gt;
 &lt;td&gt;More Joel on Software&lt;/td&gt;
 &lt;td&gt;Joel Spolsky&lt;/td&gt;
 &lt;td&gt;2008&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;22&lt;/td&gt;
 &lt;td&gt;Clean code&lt;/td&gt;
 &lt;td&gt;Robert C. Martin&lt;/td&gt;
 &lt;td&gt;2008&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;23&lt;/td&gt;
 &lt;td&gt;Coders at Work&lt;/td&gt;
 &lt;td&gt;Peter Siebel&lt;/td&gt;
 &lt;td&gt;2009&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;24&lt;/td&gt;
 &lt;td&gt;Beautiful Architecture&lt;/td&gt;
 &lt;td&gt;Diomidis Spinellis, Georgios Gousios&lt;/td&gt;
 &lt;td&gt;2009&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;25&lt;/td&gt;
 &lt;td&gt;Hackers &amp;amp; Painters&lt;/td&gt;
 &lt;td&gt;Paul Graham&lt;/td&gt;
 &lt;td&gt;2010&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;26&lt;/td&gt;
 &lt;td&gt;The Clean Coder&lt;/td&gt;
 &lt;td&gt;Robert Martin&lt;/td&gt;
 &lt;td&gt;2011&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;27&lt;/td&gt;
 &lt;td&gt;Designing Data-Intensive Applications&lt;/td&gt;
 &lt;td&gt;Martin Kleppmann&lt;/td&gt;
 &lt;td&gt;2017&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;28&lt;/td&gt;
 &lt;td&gt;Clean Architecture&lt;/td&gt;
 &lt;td&gt;Robert C. Martin&lt;/td&gt;
 &lt;td&gt;2017&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;29&lt;/td&gt;
 &lt;td&gt;Refactoring&lt;/td&gt;
 &lt;td&gt;Martin Fowler, Kent Beck&lt;/td&gt;
 &lt;td&gt;2018&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;30&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://yingang.github.io/aposd2e-zh/"&gt;A Philosophy of Software Design&lt;/a&gt;&lt;/td&gt;
 &lt;td&gt;John Ousterhout&lt;/td&gt;
 &lt;td&gt;2018&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;31&lt;/td&gt;
 &lt;td&gt;Large Scale C++&lt;/td&gt;
 &lt;td&gt;John Debbie Lafferty, John Lakos&lt;/td&gt;
 &lt;td&gt;2019&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;32&lt;/td&gt;
 &lt;td&gt;Fundamentals of Software Architecture&lt;/td&gt;
 &lt;td&gt;Mark Richards, Neal Ford&lt;/td&gt;
 &lt;td&gt;2020&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;33&lt;/td&gt;
 &lt;td&gt;Software Architecture: The Hard Parts&lt;/td&gt;
 &lt;td&gt;Neal Ford, Mark Richards, Pramod Sadalage, Zhamak Dehghani&lt;/td&gt;
 &lt;td&gt;2021&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;34&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://aosabook.org/en/index.html"&gt;The Architecture of Open Source Applications&lt;/a&gt;&lt;/td&gt;
 &lt;td&gt;Amy Brown, Greg Wilson&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;tr&gt;
 &lt;td style="text-align: center"&gt;35&lt;/td&gt;
 &lt;td&gt;&lt;a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/"&gt;Cloud Design Patterns&lt;/a&gt;&lt;/td&gt;
 &lt;td&gt;Microsoft&lt;/td&gt;
 &lt;td&gt;&lt;/td&gt;
 &lt;/tr&gt;
 &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;参考： &lt;a href="https://www.shortform.com/best-books/genre/best-software-architecture-books-of-all-time"&gt;https://www.shortform.com/best-books/genre/best-software-architecture-books-of-all-time&lt;/a&gt;&lt;/p&gt;</description></item><item><title>J 语言学习笔记</title><link>/posts/learning-j-language/</link><pubDate>Tue, 25 Apr 2023 22:00:00 +0800</pubDate><guid>/posts/learning-j-language/</guid><description>&lt;h2 id="apl-家族"&gt;APL 家族&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://aplwiki.com/wiki/Overview#Dialects"&gt;APL dialects&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Dyalog APL, GNU APL, KAP&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;J, K, Q, BQN&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="j-primer"&gt;J Primer&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.jsoftware.com/help/primer/contents.htm"&gt;Primer Contents&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;七种词性(parts of speech): noun, verb, modifier(adverb, conjunction), copula, punctuation, control word&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ambivalence: monadic, dyadic&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.jsoftware.com/help/primer/checkpoint_e.htm"&gt;rank&lt;/a&gt;: atom, list, table, array, axis, shape, rank, frame, cell, item, k-cell, agreement&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://aplwiki.com/wiki/Train"&gt;function train&lt;/a&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;2-train, hook(Dyalog 里定义为 atop，J 使用 @ 表示 atop)&lt;/li&gt;
&lt;li&gt;3-train, fork&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://aplwiki.com/wiki/Function_styles"&gt;Function styles&lt;/a&gt;&lt;/p&gt;</description></item><item><title>走出焦油坑</title><link>/posts/out-of-tar-pit/</link><pubDate>Wed, 25 Jan 2023 21:00:00 +0800</pubDate><guid>/posts/out-of-tar-pit/</guid><description>&lt;p&gt;Nubank 收购 Clojure 语言背后的公司 Cognitect 时发表的&lt;a href="https://building.nubank.com.br/welcoming-cognitect-nubank/"&gt;一篇文章&lt;/a&gt;引用了《&lt;a href="https://github.com/papers-we-love/papers-we-love/blob/master/design/out-of-the-tar-pit.pdf"&gt;走出焦油坑&lt;/a&gt;》这篇论文，看完还是有点收获的，记录点笔记。&lt;/p&gt;
&lt;p&gt;程序的复杂度在于 state 和 control，control指命令式的分支、循环，一步步执行代码。OOP 在这两方面都很差，封装和修改导致状态难以跟踪，Functional Programming 因强调 immutability 减少了 state 方面的复杂度，Logical Programming 因强调做什么(logic)而非怎么做(control)减少了 control 方面的复杂度，由此受启发，应对复杂度有两条路：&lt;/p&gt;</description></item><item><title>Scala 学习笔记</title><link>/posts/learning-scala/</link><pubDate>Fri, 18 Nov 2022 23:39:38 +0800</pubDate><guid>/posts/learning-scala/</guid><description>&lt;p&gt;&lt;a href="https://docs.scala-lang.org"&gt;https://docs.scala-lang.org&lt;/a&gt; 网站上文档的学习笔记。&lt;/p&gt;
&lt;h2 id="getting-started"&gt;Getting Started&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;a href="https://get-coursier.io/docs/cli-overview"&gt;Coursier&lt;/a&gt;安装 amm, sbt, sbtn, scala, scala-cli, scalac, scalafmt。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建项目：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-bash" data-lang="bash"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sbt new scala/scala3.g8 &lt;span style="color:#60a0b0;font-style:italic"&gt;# Scala 3&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;sbt new scala/hello-world.g8 &lt;span style="color:#60a0b0;font-style:italic"&gt;# Scala 2&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Scala 3 例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-scala" data-lang="scala"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#555;font-weight:bold"&gt;@main&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;def&lt;/span&gt; &lt;span style="color:#0e84b5;font-weight:bold"&gt;HelloWorld&lt;/span&gt;&lt;span style="color:#666"&gt;(&lt;/span&gt;args&lt;span style="color:#007020;font-weight:bold"&gt;:&lt;/span&gt; &lt;span style="color:#902000"&gt;String*&lt;/span&gt;&lt;span style="color:#666"&gt;)&lt;/span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;:&lt;/span&gt; &lt;span style="color:#902000"&gt;Unit&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; println&lt;span style="color:#666"&gt;(&lt;/span&gt;&lt;span style="color:#4070a0"&gt;&amp;#34;Hello world!&amp;#34;&lt;/span&gt;&lt;span style="color:#666"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Scala 2 例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-scala" data-lang="scala"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;object&lt;/span&gt; &lt;span style="color:#0e84b5;font-weight:bold"&gt;Main&lt;/span&gt; &lt;span style="color:#666"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;def&lt;/span&gt; main&lt;span style="color:#666"&gt;(&lt;/span&gt;args&lt;span style="color:#007020;font-weight:bold"&gt;:&lt;/span&gt; &lt;span style="color:#902000"&gt;Array&lt;/span&gt;&lt;span style="color:#666"&gt;[&lt;/span&gt;&lt;span style="color:#902000"&gt;String&lt;/span&gt;&lt;span style="color:#666"&gt;])&lt;/span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;:&lt;/span&gt; &lt;span style="color:#902000"&gt;Unit&lt;/span&gt; &lt;span style="color:#666"&gt;=&lt;/span&gt; &lt;span style="color:#666"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; println&lt;span style="color:#666"&gt;(&lt;/span&gt;&lt;span style="color:#4070a0"&gt;&amp;#34;Hello world!&amp;#34;&lt;/span&gt;&lt;span style="color:#666"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; &lt;span style="color:#666"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;div class="highlight"&gt;&lt;pre tabindex="0" style="background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"&gt;&lt;code class="language-scala" data-lang="scala"&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;// 在 Scala 3 里不再推荐这种写法
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;// https://www.scala-lang.org/api/current/scala/App.html
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#60a0b0;font-style:italic"&gt;&lt;/span&gt;&lt;span style="color:#007020;font-weight:bold"&gt;object&lt;/span&gt; &lt;span style="color:#0e84b5;font-weight:bold"&gt;Main&lt;/span&gt; &lt;span style="color:#007020;font-weight:bold"&gt;extends&lt;/span&gt; &lt;span style="color:#0e84b5;font-weight:bold"&gt;App&lt;/span&gt; &lt;span style="color:#666"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt; println&lt;span style="color:#666"&gt;(&lt;/span&gt;&lt;span style="color:#4070a0"&gt;&amp;#34;Hello, World!&amp;#34;&lt;/span&gt;&lt;span style="color:#666"&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style="display:flex;"&gt;&lt;span&gt;&lt;span style="color:#666"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ol start="3"&gt;
&lt;li&gt;
&lt;p&gt;输入 &lt;code&gt;sbt&lt;/code&gt; 命令进入 SBT console，输入 &lt;code&gt;~run&lt;/code&gt; 以在文件发生变动时重新运行 main。按回车键中断 &lt;code&gt;run&lt;/code&gt; 命令，输入 &lt;code&gt;exit&lt;/code&gt; 或者 &lt;kbd&gt;Ctrl-D&lt;/kbd&gt; 退出 sbt。&lt;/p&gt;</description></item><item><title>《BeyondCorp: A New Approach to Enterprise Security》总结</title><link>/posts/beyond-corp-and-zero-trust/</link><pubDate>Mon, 20 Sep 2021 20:45:21 +0800</pubDate><guid>/posts/beyond-corp-and-zero-trust/</guid><description>&lt;p&gt;零信任网络架构的研究由来已久，Google 的这篇 BeyondCorp 论文让这个概念广为认知，毕竟 Google 名气太大。这篇工程实践论文可读性很好，对企业办公网络的安全设计实操非常有帮助，总结一下关键点：&lt;/p&gt;</description></item><item><title>给孩子的书法</title><link>/posts/calligraphy-for-children/</link><pubDate>Sat, 13 Jun 2020 10:00:00 +0800</pubDate><guid>/posts/calligraphy-for-children/</guid><description>&lt;p&gt;《给孩子的书法》，刘涛，中信出版集团，2018-05&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;书法演变小史&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;篆书 (甲骨文，金文，石鼓文，简书，帛书，只是书写材质不同)&lt;/li&gt;
&lt;li&gt;隶书 (篆书的俗体)&lt;/li&gt;
&lt;li&gt;草书，行书，楷书(都是隶书的俗体)，晋朝成熟&lt;/li&gt;
&lt;li&gt;东汉 张芝 草圣&lt;/li&gt;
&lt;li&gt;魏国 钟繇 隶，行，楷，只有楷书流传下来真迹&lt;/li&gt;
&lt;li&gt;东晋 王羲之 书圣&lt;/li&gt;
&lt;li&gt;欧阳询 九成宫醴泉铭&lt;/li&gt;
&lt;li&gt;虞世南&lt;/li&gt;
&lt;li&gt;褚遂良&lt;/li&gt;
&lt;li&gt;颜真卿 多宝塔碑，麻姑仙坛记，颜家庙碑&lt;/li&gt;
&lt;li&gt;柳公权 玄秘塔碑&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;篆书&lt;/p&gt;</description></item><item><title>乌合之众：大众心理研究</title><link>/posts/the-crowd-a-study-of-the-popular-mind/</link><pubDate>Sun, 17 May 2020 22:17:36 +0800</pubDate><guid>/posts/the-crowd-a-study-of-the-popular-mind/</guid><description>&lt;p&gt;《乌合之众：大众心理研究》，古斯塔夫・勒庞 著，陈剑 译，译林出版社，2016-01&lt;/p&gt;</description></item><item><title>Help Your Kids With Maths</title><link>/posts/help-your-kids-with-maths/</link><pubDate>Sun, 03 May 2020 18:55:51 +0800</pubDate><guid>/posts/help-your-kids-with-maths/</guid><description>&lt;p&gt;《Help Your Kids With Maths》，by Carol Voderman&lt;/p&gt;
&lt;h2 id="1-numbers"&gt;1. Numbers&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;各种数字符号：现代印度-阿拉伯数字，玛雅数字，中文数字，罗马数字，埃及数字，巴比伦数字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;addition, subtraction, multiplication, division: 加减乘除&lt;/p&gt;</description></item><item><title>《The Rust Programming Language》笔记</title><link>/posts/the-rust-programming-language/</link><pubDate>Thu, 23 Jan 2020 23:43:30 +0800</pubDate><guid>/posts/the-rust-programming-language/</guid><description>&lt;h2 id="1-getting-started"&gt;1. Getting Started&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;使用 &lt;code&gt;rustup&lt;/code&gt; 安装，默认安装在 &lt;code&gt;$HOME/.cargo&lt;/code&gt; 和 &lt;code&gt;$HOME/.rustup&lt;/code&gt; 下&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rustup update&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rustup self uninstall&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;cargo 常用命令
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;cargo new PROJECT&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cargo build [--release]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cargo run&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="2-programming-a-guessing-game"&gt;2. Programming a Guessing Game&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Cargo.toml&lt;/code&gt; 里依赖部分的版本号 &amp;ldquo;MAJOR.MINOR.PATCH&amp;rdquo; 实际是 &amp;ldquo;^MAJOR.MINOR.PATCH&amp;rdquo; 的简写，表示允许语义版本的升级&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cargo update&lt;/code&gt; 默认只升级 PATCH 部分&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cargo doc --open&lt;/code&gt; 查看文档&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="3-common-programming-concepts"&gt;3. Common Programming Concepts&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;不可变变量：&lt;code&gt;let VAR: TYPE = VALUE;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;可变变量：&lt;code&gt;let mut VAR: TYPE = VALUE;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;常量：&lt;code&gt;const FOO_BAR: TYPE = VALUE;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Shadowing: 同一作用域里，同名变量可以重复声明，之前声明的变量被遮蔽。&lt;/li&gt;
&lt;li&gt;Scalar types:
&lt;ol&gt;
&lt;li&gt;Integer types: i8, u8, i16, u16, i32, u32, i64, u64, i128, u128, isize, usize，后两者长度跟机器相关，一般用于集合、数组的索引和长度。Debug 模式下溢出回绕会panic，Release模式下溢出回绕不报错。使用标准库里类型 Wrapping 显示表明期望溢出回绕行为。&lt;/li&gt;
&lt;li&gt;Integer literals: 98_222, 0xff, 0o77, 0b1111_0000, b&amp;rsquo;A&amp;rsquo;，除了 byte literal，其它字面量都支持类型后缀，比如 57u8 表示一个 u8 类型的值 57。&lt;strong&gt;整型字面量默认类型为 i32&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Floating-point types: f32, f64，&lt;strong&gt;默认为 f64&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Boolean type: bool, true, false。布尔类型长度为一字节。&lt;/li&gt;
&lt;li&gt;Character type: char，四个字节，表示一个 Unicode Scalar Value, 范围为 [U+0000, U+D7FF] 和 [U+E000, U+10FFFF]。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Compound Types
&lt;ol&gt;
&lt;li&gt;Tuple: (x, y, z)，类型声明 (t1, t2, t3)&lt;/li&gt;
&lt;li&gt;Array: [x, y, z]，类型声明 [t; size]。 使用语法 [x; n] 创建 n 个 x 值的数组。数据访问会检查是否越界。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Functions: &lt;code&gt;fn foo(x:t1, y:t2) -&amp;gt; t3 { ... }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Control flow:
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;if condition { ... } else if condition { ... } else { ... }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;loop { .... break VALUE; ... }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;while condition { ... }&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;for VAR in ITER { ... }&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="4-understanding-ownership"&gt;4. Understanding Ownership&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Ownership rules：没有实现 Copy trait 的类型，变量赋值时是 move 语义，owner 超出作用域时自动调用 drop()&lt;/p&gt;</description></item><item><title>Wolfram 语言：快速编程入门</title><link>/posts/wolfram-language-fast-introduction-for-programmers/</link><pubDate>Tue, 27 Aug 2019 23:37:29 +0800</pubDate><guid>/posts/wolfram-language-fast-introduction-for-programmers/</guid><description>&lt;p&gt;&lt;a href="http://www.wolfram.com/language/fast-introduction-for-programmers/zh/"&gt;http://www.wolfram.com/language/fast-introduction-for-programmers/zh/&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Shift + Enter&lt;/code&gt; 开始计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Quit&lt;/code&gt; 退出当前 Math Kernel 会话，再次计算会自动启动新的 Math Kernel 会话&lt;/li&gt;
&lt;li&gt;&lt;code&gt;In[n]&lt;/code&gt;, &lt;code&gt;Out[n]&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt; 表示上一次输出, &lt;code&gt;%%&lt;/code&gt;表示上上次输出，依次类推；&lt;code&gt;%n&lt;/code&gt; 表示 &lt;code&gt;Out[n]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;kbd&gt;CMD&lt;/kbd&gt;+&lt;kbd&gt;L&lt;/kbd&gt; 复制并粘贴上一次输入&lt;/li&gt;
&lt;li&gt;所有符号表达式都具有相同的基本结构：&lt;code&gt;head[arguments]&lt;/code&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;FullForm[expr]&lt;/code&gt;: 显示底层结构&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Head[expr]&lt;/code&gt;: 给出表达式的头部&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Length[expr]&lt;/code&gt;: 给出表达式中参数的个素&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;List
&lt;ol&gt;
&lt;li&gt;字面语法：&lt;code&gt;{a, b, c}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;索引：&lt;code&gt;list[[i]]&lt;/code&gt;, &lt;code&gt;i&lt;/code&gt; 从 1 开始，负数表示从末尾开始计数&lt;/li&gt;
&lt;li&gt;许多运算符都是向量化运算，比如 &lt;code&gt;{1, 2, 3} + 2&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;列表切片：&lt;code&gt;list[[i ;; j]]&lt;/code&gt;，闭区间&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Iterator
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Table[x^2, {x, MAX}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Table[x^2, {x, MIN, MAX}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Table[x^2, {x, MIN, MAX, STEP}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Table[x * y, {x, ...}, {y, ...}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Array[f, n]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Assignment
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 表示立即赋值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:=&lt;/code&gt; 表示延迟复制，被用到时重新计算&lt;/li&gt;
&lt;li&gt;&lt;code&gt;var = .&lt;/code&gt; 清除赋值&lt;/li&gt;
&lt;li&gt;局部变量：&lt;code&gt;Module[{a = 1}, a + 8]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Pattern
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;_&lt;/code&gt; （读做 blank）表示任意表达式: &lt;code&gt;Replace[f[100]， f[x_] -&amp;gt; x + 5]&lt;/code&gt;，这里 &lt;code&gt;x_&lt;/code&gt; 是 &lt;code&gt;x: _&lt;/code&gt; 的简写&lt;/li&gt;
&lt;li&gt;&lt;code&gt;__&lt;/code&gt; (double blank) 表示任意表达式序列：&lt;code&gt;Cases[{f[1, 2], f[1], g[3]}, f[__]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;a | b | c&lt;/code&gt; 表示或者：
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;Cases[{f[1], g[2], f[2], f[5]}, f[1 | 5]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Cases[{f[1], g[2], f[2], f[5]}, (f | g)[2]]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;_head&lt;/code&gt; 匹配包含头部 &lt;code&gt;head&lt;/code&gt; 的表达式：&lt;code&gt;Cases[{1, 2.5, 3.5, 4}, _Real]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-&amp;gt;&lt;/code&gt; 使用模式来定义规则，规则右边的表达式在定义时即计算: &lt;code&gt;f[x_] -&amp;gt; x + RandomReal[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:&amp;gt;&lt;/code&gt; 与 &lt;code&gt;-&amp;gt;&lt;/code&gt; 的区别是在规则使用时才计算右边表达式： &lt;code&gt;f[x_] :&amp;gt; x + RandomReal[]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/.&lt;/code&gt; 表示&amp;quot;替换所有”（应用重写规则)： &lt;code&gt;{f[1], g[2], f[5], g[3]} /. f[x_] -&amp;gt; x + 5&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[x_, y_] := x - y&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[x_, y_] := x - y /; x &amp;gt; y&lt;/code&gt;, &lt;code&gt;/; x &amp;gt; y&lt;/code&gt; 表示当 x &amp;gt; y 时才应用这个函数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;f[1] = 2&lt;/code&gt;, &lt;code&gt;f[2] = 3&lt;/code&gt;， 定义过的 case 会计算，没定义的 case 保留原样: &lt;code&gt;{f[1], f[2], f[3], f[4]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Clear[f]&lt;/code&gt; 清除函数定义&lt;/li&gt;
&lt;li&gt;Pure function(匿名函数，lambda 表达式)
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;expr &amp;amp;&lt;/code&gt;， 表达式中的 # 或者 #1 表示第一个参数，#2 表示第二个参数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Function[{x, y}, expr]&lt;/code&gt;，命名参数的匿名函数&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Apply function&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map[f, {a, b, c, d}]&lt;/code&gt;, 简写 &lt;code&gt;f /@ {a, b, c, d}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Map[f, expr, levelspec]&lt;/code&gt;，默认在 level 1 操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Apply[f, {a, b, c, d}]]&lt;/code&gt; 等价于 &lt;code&gt;f[a, b, c, d]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Apply[f, expr, levelspec]&lt;/code&gt;，默认在 level 0 操作，将 expr 的对应 level 的 head 替换成 f&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@&lt;/code&gt; 是普通函数调用：&lt;code&gt;f @ {{a, b}, {c, d}}&lt;/code&gt; 等价于 &lt;code&gt;f[{{a, b}, {c, d}}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@@&lt;/code&gt; 等价于 &lt;code&gt;Apply&lt;/code&gt;(apply at level 0): &lt;code&gt;f @@ {{a, b}, {c, d}}&lt;/code&gt; 等价于 &lt;code&gt;f[{a, b}, {c, d}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@@@&lt;/code&gt; 等价于 &amp;ldquo;apply at level 1&amp;rdquo;: &lt;code&gt;f @@@ {{a, b}, {c, d}}&lt;/code&gt; 等价于 &lt;code&gt;{f[a, b], f[c, d]}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;expr // f&lt;/code&gt; 等价于 &lt;code&gt;f[expr]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NestList[f, x, n]&lt;/code&gt; 相当于 &lt;code&gt;{x, f[x], f[f[x]], ...}&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Nest[f, x, n]&lt;/code&gt; 相当于 &lt;code&gt;f[f[f[....f[x]]]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;NestGraph[f, x, n]&lt;/code&gt; 嵌套的应用 f，形成一个图&lt;/li&gt;
&lt;li&gt;&lt;code&gt;FoldList[f, x, list]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数选项(Options)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Func[arguments, nameA -&amp;gt; valueA, ...]&lt;/code&gt;， 使用 &lt;code&gt;:&amp;gt;&lt;/code&gt; 替换 &lt;code&gt;-&amp;gt;&lt;/code&gt; 表示每次用到这个 option 时都重新计算（跟 rule 的定义方式一致)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Options[Func]&lt;/code&gt; 查看函数的所有选项&lt;/li&gt;
&lt;li&gt;Graphics&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ListLinePlot[{5, 6, 1, 5, 7, 8, 1, 3}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Graph[{1 -&amp;gt; 3, 1 -&amp;gt; 2, 2 -&amp;gt; 4, 4 -&amp;gt; 5, 5 -&amp;gt; 1}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Graphics[{Orange, Disk[{0, 0}], Opacity[.7], Pink, Disk[{1, 0}]}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Interactive Interaces&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Manipulate[Plot[Sin[a x], {x, 0, 10}], {a, 1, 5}]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;过程式编程&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Print[a]; Print[b]; Print[c]&lt;/code&gt; 分号分隔表达式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Module[]&lt;/code&gt; 词法作用域，变量存放在后端（Math Kernel） 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Block[]&lt;/code&gt; 动态作用域&lt;/li&gt;
&lt;li&gt;&lt;code&gt;DynamicModule[]&lt;/code&gt; 词法作用域，变量存放在前端（Notebook） 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Sow/Reap&lt;/code&gt; vs. &lt;code&gt;Throw/Catch&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;True&lt;/code&gt;, &lt;code&gt;False&lt;/code&gt;, &lt;code&gt;If&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数字: &lt;code&gt;N[expr, precision]&lt;/code&gt; 和 &lt;code&gt;expr`precision&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串:&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; 连接字符串&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~~&lt;/code&gt; 连接正则表达式和字符串&lt;/li&gt;
&lt;li&gt;输入 Unicode 字符：&lt;code&gt;\[Alpha]&lt;/code&gt;, &lt;kbd&gt;ESC&lt;/kbd&gt;&lt;kbd&gt;A&lt;/kbd&gt;&lt;kbd&gt;ESC&lt;/kbd&gt;, &lt;code&gt;\:03b1&lt;/code&gt; 都是输入 &lt;code&gt;α&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串模版：&lt;code&gt;TemplateApply[&amp;quot;number `` date: &amp;lt;* Now *&amp;gt;&amp;quot;, {56}]&lt;/code&gt;, `` 表示占位符，&lt;code&gt;&amp;lt;* expr *&amp;gt;&lt;/code&gt; 表示插值&lt;/li&gt;
&lt;li&gt;关联 (Associations)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;|&amp;quot;a&amp;quot; -&amp;gt; x, &amp;quot;b&amp;quot; -&amp;gt; y|&amp;gt;&lt;/code&gt; 定义关联，&lt;code&gt;expr[key]&lt;/code&gt; 获取值&lt;/li&gt;
&lt;li&gt;匿名函数中可以用 &lt;code&gt;#key&lt;/code&gt; 得到关联中的值：&lt;code&gt;{#b, 1 + #b}&amp;amp;[&amp;lt;|&amp;quot;a&amp;quot;-&amp;gt;x, &amp;quot;b&amp;quot;-&amp;gt;y|&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;关联和列表同时使用：&lt;code&gt;&amp;lt;|&amp;quot;a&amp;quot; -&amp;gt; x, &amp;quot;b&amp;quot; -&amp;gt; {5, 6}|&amp;gt;[[&amp;quot;b&amp;quot;, 1]]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;字符串模版：&lt;code&gt;TemplateApply[&amp;quot;first `a`; second `b`; first `a`&amp;quot;, &amp;lt;|&amp;quot;a&amp;quot; -&amp;gt; x, &amp;quot;b&amp;quot; -&amp;gt; y|&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>《人工智能简史》，尼克 著</title><link>/posts/a-brief-history-of-artificial-intelligence/</link><pubDate>Thu, 25 Jul 2019 22:00:00 +0800</pubDate><guid>/posts/a-brief-history-of-artificial-intelligence/</guid><description>&lt;h2 id="目录"&gt;目录&lt;/h2&gt;
&lt;pre tabindex="0"&gt;&lt;code&gt;第1章　达特茅斯会议：人工智能的缘起
第2章　自动定理证明兴衰纪
第3章　从专家系统到知识图谱
第4章　第五代计算机的教训
第5章　神经网络简史
第6章　计算机下棋简史：机定胜人，人定胜天
第7章　自然语言处理
第8章　向自然学习：从遗传算法到强化学习
第9章　哲学家和人工智能
第10章　人是机器吗？——人工智能的计算理论基础
第11章　智能的进化
第12章　当我们谈论生死时，我们在谈论什么？
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id="人工智能的计算理论基础"&gt;人工智能的计算理论基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;丘奇-图灵论题（Church-Turing Thesis）：所有功能足够强的计算装置的计算能力都等价于图灵机。这是一个观察，而不是定理。 （可计算性)&lt;/li&gt;
&lt;li&gt;理论计算机科学家洪加威在20世纪80年代提出了相似性原则：计算装置之间互相模拟的成本是多项式的，也就是说靠谱的计算装置之间并不存在原则上的差异。相似性原则，类似于丘奇-图灵论题，是观察而不是数学定理。(计算复杂性)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="人工智能三大流派"&gt;人工智能三大流派&lt;/h2&gt;
&lt;p&gt;&lt;img src="images/%E9%80%BB%E8%BE%91%E4%B8%BB%E4%B9%89.jpg" alt="逻辑主义"&gt;
&lt;img src="images/%E8%81%94%E6%8E%A5%E4%B8%BB%E4%B9%89.jpg" alt="联接主义"&gt;
&lt;img src="images/%E8%87%AA%E7%84%B6%E4%B8%BB%E4%B9%89.jpg" alt="自然主义"&gt;&lt;/p&gt;</description></item><item><title>Unicode 11.0 其它规范一瞥</title><link>/posts/unicode-more-specs/</link><pubDate>Mon, 07 Jan 2019 15:27:02 +0800</pubDate><guid>/posts/unicode-more-specs/</guid><description>&lt;p&gt;下面的内容不属于 Core Spec，但也很重要。&lt;/p&gt;
&lt;h2 id="unicode-standard-annexes"&gt;Unicode Standard Annexes&lt;/h2&gt;
&lt;h3 id="uax-9-the-unicode-bidirectional-algorithm"&gt;UAX #9, The Unicode Bidirectional Algorithm&lt;/h3&gt;
&lt;h3 id="uax-11-east-asian-width"&gt;UAX #11, East Asian Width&lt;/h3&gt;
&lt;h3 id="uax-14-unicode-line-breaking-algorithm"&gt;UAX #14, Unicode Line Breaking Algorithm&lt;/h3&gt;
&lt;h3 id="uax-15-unicode-normalization-forms"&gt;UAX #15, Unicode Normalization Forms&lt;/h3&gt;
&lt;h3 id="uax-24-unicode-script-property"&gt;UAX #24, Unicode Script Property&lt;/h3&gt;
&lt;h3 id="uax-29-unicode-text-segmentation"&gt;UAX #29, Unicode Text Segmentation&lt;/h3&gt;
&lt;h3 id="uax-31-unicode-identifier-and-pattern-syntax"&gt;UAX #31, Unicode Identifier and Pattern Syntax&lt;/h3&gt;
&lt;h3 id="uax-34-unicode-named-character-sequences"&gt;UAX #34, Unicode Named Character Sequences&lt;/h3&gt;
&lt;h3 id="uax-38-unicode-han-database-unihan"&gt;UAX #38, Unicode Han Database (Unihan)&lt;/h3&gt;
&lt;h3 id="uax-41-common-references-for-unicode-standard-annexes"&gt;UAX #41, Common References for Unicode Standard Annexes&lt;/h3&gt;
&lt;h3 id="uax-42-unicode-character-database-in-xml"&gt;UAX #42, Unicode Character Database in XML&lt;/h3&gt;
&lt;h3 id="uax-44-unicode-character-database"&gt;UAX #44, Unicode Character Database&lt;/h3&gt;
&lt;h3 id="uax-45-u-source-ideographs"&gt;UAX #45, U-Source Ideographs&lt;/h3&gt;
&lt;h3 id="uax-50-unicode-vertical-text-layout"&gt;UAX #50, Unicode Vertical Text Layout&lt;/h3&gt;
&lt;h2 id="unicode-technical-standards-and-reports"&gt;Unicode Technical Standards and Reports&lt;/h2&gt;
&lt;h3 id="uts-10-unicode-collation-algorithm"&gt;UTS #10, Unicode Collation Algorithm&lt;/h3&gt;
&lt;h3 id="uts-39-unicode-security-mechanism"&gt;UTS #39, Unicode Security Mechanism&lt;/h3&gt;
&lt;h3 id="uts-46-unicode-idna-compatibility-processing"&gt;UTS #46, Unicode IDNA Compatibility Processing&lt;/h3&gt;
&lt;h3 id="uts-51-unicode-emoji"&gt;UTS #51, Unicode Emoji&lt;/h3&gt;
&lt;h2 id="附汉字分类术语"&gt;附：汉字分类术语&lt;/h2&gt;
&lt;p&gt;参考 &lt;a href="https://shurufa.app/docs/concepts.html#_2-8-%E4%BC%A0%E6%89%BF%E5%AD%97"&gt;https://shurufa.app/docs/concepts.html#_2-8-%E4%BC%A0%E6%89%BF%E5%AD%97&lt;/a&gt;&lt;/p&gt;</description></item><item><title>Unicode 11.0 核心规范笔记</title><link>/posts/unicode-core-spec/</link><pubDate>Thu, 03 Jan 2019 23:27:02 +0800</pubDate><guid>/posts/unicode-core-spec/</guid><description>&lt;h2 id="导言"&gt;导言&lt;/h2&gt;
&lt;p&gt;前几天以戏谑的语气写了些 &lt;a href="../you-dont-understand-unicode/"&gt;Unicode 规范的坑点&lt;/a&gt;，了解有限，很不严谨，Unicode 技术委员会成员&lt;a href="https://www.zhihu.com/people/lianghai/activities"&gt;梁海&lt;/a&gt;同学指出概念不清，建议读一下 &lt;a href="http://www.unicode.org/versions/Unicode11.0.0/"&gt;Unicode Core Spec&lt;/a&gt;，本文是对 Core Spec 的一点笔记。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;由于 Core Spec 很长，这份笔记也会比较长，所以先总结一点个人猜度的编程语言中 char 和 string 的设计考虑。&lt;/p&gt;</description></item></channel></rss>